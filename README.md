# POC DE CONHECIMENTO A CERCA DE INVOCAÇÃO ASSÍNCRONA DE LAMBDAS AWS

# CONTEXTO

UMA LAMBDA MÃE (loopPlayers) É INVOCADA ATRAVÉS DE UMA REQUISIÇÃO HTTP (OU CRONJOB),
E ITERA SOBRE UM CONJUNTO DE JOGADORES (players) DE FORMA ASSÍNCRONA. A LAMBDA MÃE NÃO DEVE
FICAR TRAVADA AGUARDANDO O PROCESSO DA LAMBDA FILHA TERMINAR.

## O QUE SE ESPERA ?

SEQUÊNCIA DE LOGS:

1. [loopPlayers] LOG START - GET ALL PLAYERS AND INVOKE FOR EACH ONE
2. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 2
3. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 1
4. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 3
5. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 1
6. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 2
7. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 3
8. [printPlayer] LOG 1 - START FOR PLAYER 1
9. [printPlayer] LOG 1 - START FOR PLAYER 2
10. [printPlayer] LOG 1 - START FOR PLAYER 3
11. [printPlayer] LOG 2 - AFTER 1000 MS FOR PLAYER 2
12. [printPlayer] LOG 2 - AFTER 1000 MS FOR PLAYER 1
13. [printPlayer] LOG 2 - AFTER 1000 MS FOR PLAYER 3
14. [printPlayer] LOG 3 - END FOR PLAYER 1
15. [printPlayer] LOG 3 - END FOR PLAYER 2
16. [printPlayer] LOG 3 - END FOR PLAYER 3

DE 1 A 7 PERCEBEMOS QUE A LAMBDA MÃE (loopPlayers) NÃO ESPERA A LAMBDA FILHA (printPlayer)
FINALIZAR PARA CONTINUAR SEU FLUXO.

# TESTES

## CASO 1: InvocationType="RequestResponse" e lambda.invoke com await

SEQUÊNCIA DE LOGS:

1. [loopPlayers] LOG START - GET ALL PLAYERS AND INVOKE FOR EACH ONE
2. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 3
3. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 1
4. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 3
5. [printPlayer] LOG 1 - START FOR PLAYER 1
6. [printPlayer] LOG 1 - START FOR PLAYER 3
7. [printPlayer] LOG 1 - START FOR PLAYER 2
8. [printPlayer] LOG 2 - AFTER 1000 MS FOR PLAYER 1
9. [printPlayer] LOG 2 - AFTER 1000 MS FOR PLAYER 2
10. [printPlayer] LOG 2 - AFTER 1000 MS FOR PLAYER 3
11. [printPlayer] LOG 3 - END FOR PLAYER 1
12. [printPlayer] LOG 3 - END FOR PLAYER 2
13. [printPlayer] LOG 3 - END FOR PLAYER 3
8. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 1
9. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 2
10. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 3

DE 1 A 4 PERCEBEMOS QUE A LAMBDA MÃE (loopPlayers) INICIA SEU PROCESSO, EM SEGUIDA
DE 5 A 13 A LAMBDA FILHA (printPlayer) EXECUTA TODO SEU PROCESSO E SÓ ENTÃO A
LAMBDA MÃE (loopPlayers) RETORNA AO SEU FLUXO. LOGO A LAMBDA MÃE AGUARDA O PROCESSAMENTO
DA LAMBDA FILHA. SE QUISER VERIFICAR UM ERRO DE TIMEOUT NA LAMBDA MÃE DEVIDO AO AGUARDO
DA EXECUÇÃO DA LAMBDA FILHA BASTA AUMENTAR O DELAY NA LAMBDA FILHA.

## CASO 2: InvocationType="RequestResponse" e lambda.invoke sem await

SEQUÊNCIA DE LOGS:

1. [loopPlayers] LOG START - GET ALL PLAYERS AND INVOKE FOR EACH ONE
2. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 3
3. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 2
4. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 1
5. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 3
6. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 2
7. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 1

DE 1 A 4 PERCEBEMOS QUE A LAMBDA MÃE (loopPlayers) INICIA SEU PROCESSO, EM SEGUIDA
DE 5 A 8 PERCEBEMOS QUE A LAMBDA MÃE TERMINA SEU FLUXO. E A LAMBDA FILHA ? NÃO FOI EXECUTADA!
O PROCESSAMENTO DA LAMBDA MÃE FOI TÃO RÁPIDO QUE A LAMBDA FOI MORTA ANTES MESMO DE TERMINAR A
INVOCAÇÃO DA LAMBDA SEM AWAIT.

## CASO 3: InvocationType="Event" e lambda.invoke com await

SEQUÊNCIA DE LOGS:

1. [loopPlayers] LOG START - GET ALL PLAYERS AND INVOKE FOR EACH ONE
2. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 2
3. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 1
4. [loopPlayers] LOG 1 - BEFORE INVOKE LAMBDA printPlayer FOR PLAYER 3
5. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 1
6. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 2
7. [loopPlayers] LOG 2 - AFTER INVOKE LAMBDA printPlayer FOR PLAYER 3
8. [printPlayer] LOG 1 - START FOR PLAYER 1
9. [printPlayer] LOG 1 - START FOR PLAYER 2
10. [printPlayer] LOG 1 - START FOR PLAYER 3
11. [printPlayer] LOG 2 - AFTER 1000 MS FOR PLAYER 2
12. [printPlayer] LOG 2 - AFTER 1000 MS FOR PLAYER 1
13. [printPlayer] LOG 2 - AFTER 1000 MS FOR PLAYER 3
14. [printPlayer] LOG 3 - END FOR PLAYER 1
15. [printPlayer] LOG 3 - END FOR PLAYER 2
16. [printPlayer] LOG 3 - END FOR PLAYER 3

DE 1 A 7 PERCEBEMOS QUE A LAMBDA MÃE (loopPlayers) NÃO ESPERA A LAMBDA FILHA (printPlayer)
FINALIZAR PARA CONTINUAR SEU FLUXO. PORÉM A LAMBDA FILHA É EXECUTADA CORRETAMENTE.
NESSE CASO O TIPO DEINVOCAÇÃO É DIFERENTE E O AWAIT NA HORA DE INVOCAR SIGNIFICA QUE O FLUXO
VAI ESPERAR A LAMBDA FILHA SER INVOCADA MAS NÃO VAI ESPERAR SEU RETORNO.





